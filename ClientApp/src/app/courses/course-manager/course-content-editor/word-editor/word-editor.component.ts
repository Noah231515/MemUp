import { OnChanges } from '@angular/core';
import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { Course } from 'src/app/models/course.model';
import { Sentence } from 'src/app/models/sentence.model';
import { Word } from 'src/app/models/word.model';
import { CourseService } from 'src/app/services/course.service';
import { WordService } from 'src/app/services/word.service';

@Component({
  selector: 'app-word-editor',
  templateUrl: './word-editor.component.html',
  styleUrls: ['./word-editor.component.css']
})
export class WordEditorComponent implements OnInit, OnChanges {
  @Input() public wordToEdit: Word;
  @Input() public course: Course;
  @Output() public wordUpdated = new EventEmitter<Word>();
  @Output() public wordCreated = new EventEmitter<Word>();
  @Output() public formClosed = new EventEmitter<null>();
  public wordEditorForm: FormGroup;
  public creatingNewWord: boolean;


  public constructor(
    private formBuilder: FormBuilder,
    private wordService: WordService,
    private courseService: CourseService
  ) { }

  public ngOnInit(): void {
    this.creatingNewWord = this.wordToEdit.id ? false : true;
    this.instantiateEmptyWordProperties();
    this.initializeForm();
  }

  public ngOnChanges() {
    try {
      this.initializeForm();
    } catch (error) {
      console.log(error);
    }
  }

  /**
   * Instantiates any property of the wordToEdit that is undefined, including sentences to ensure that the
   * word editor functions properly
   */
  public instantiateEmptyWordProperties() {
    for (let property of [
      this.wordToEdit.englishVocab,
      this.wordToEdit.japaneseVocab,
      this.wordToEdit.kanaVocab,
      this.wordToEdit.partOfSpeech]
    ) {
        property = property ? property : '';
      }

    // Create blank sentences for all three sentence types if the sentences array contains no elements
    if (this.wordToEdit.sentences.length === 0) {
      this.wordToEdit.sentences = [
        this.wordService.createBlankSentence('English', this.wordToEdit),
        this.wordService.createBlankSentence('Japanese', this.wordToEdit),
        this.wordService.createBlankSentence('Furigana', this.wordToEdit),
      ];
    } else if (this.wordToEdit.sentences.length !== 3) {
      // Check that sentences for all three types exist, and if any are missing, create blank sentences and add them to the sentences array
      const sentenceTypes = ['English', 'Japanese', 'Furigana'];
      sentenceTypes.forEach((type) => {
        if (!this.wordToEdit.sentences.find(element => element.sentenceType.type === type)) {
          this.wordToEdit.sentences.push(this.wordService.createBlankSentence(type, this.wordToEdit));
        }
      });
    } else {
      // Define text for any sentence that has an uninstatiated sentenceText property
      this.wordToEdit.sentences.forEach((sentence) => {
        sentence.sentenceText = sentence.sentenceText ? sentence.sentenceText : '';
      });
    }
  }

  /**
   * Initializes the word editor form.
   */
  public initializeForm(): void {
    this.wordEditorForm = this.formBuilder.group({
      englishVocab: this.wordToEdit.englishVocab,
      japaneseVocab: this.wordToEdit.japaneseVocab,
      kanaVocab: this.wordToEdit.kanaVocab,
      partOfSpeech: this.wordToEdit.partOfSpeech,
      sentenceEnglish: this.wordToEdit.sentences[0].sentenceText,
      sentenceJapanese: this.wordToEdit.sentences[1].sentenceText,
      sentenceFurigana: this.wordToEdit.sentences[2].sentenceText,
    });
  }

  /**
   * Updates the sentenceText properties of the word's sentences using the values in the form.
   * Because sentences are always sorted by their type, we know that in the array,
   * index 0 == English, index 1 == Japanese, and index 2 == Kana.
   * @return {*}  {Sentence[]}
   */
  public getUpdatedSentences(): Sentence[] {
    const updatedSentences = this.wordToEdit.sentences.slice();

    const formValues = [
      this.wordEditorForm.value.sentenceEnglish, this.wordEditorForm.value.sentenceJapanese, this.wordEditorForm.value.sentenceFurigana
    ];
    for (let i = 0; i < 3; i++) {
      updatedSentences[i].sentenceText = formValues[i];
    }

    return updatedSentences;
  }

  /**
   * Submits the values in the form. We use this.creatingNewWord to check if we are creating a new word or editing an existing one.
   * If creating a new word, we create a new word object with a blank GUID (a real GUID will be generated by the backend), and submit
   * it once the user confirms.
   * If we are editing a word, we create an updatedWord object but ensure that the word's id as well as the course id FK remain the same.
   * We check if any changes were actually made by comparing the updated and original objects, and only submit the word if changes exist.
   */
  public submitForm(): void {
    const formValues = this.wordEditorForm.value;

    if (this.creatingNewWord) {
      const newWord: Word = {
        id: '00000000-0000-0000-0000-000000000000',
        courseId: this.course.id,
        englishVocab: formValues.englishVocab,
        japaneseVocab: formValues.japaneseVocab,
        kanaVocab: formValues.kanaVocab,
        partOfSpeech: formValues.partOfSpeech,
        sentences: this.getUpdatedSentences(),
      };
      if (confirm(`Submit "${newWord.englishVocab}" and add it to ${this.course.name}?`)) {
        this.wordService.createWord(newWord).subscribe((createdWord) => {
          this.wordCreated.emit(createdWord);
        });
      }
    } else {
      const updatedWord: Word = {
        id: this.wordToEdit.id,
        courseId: this.wordToEdit.courseId,
        englishVocab: formValues.englishVocab,
        japaneseVocab: formValues.japaneseVocab,
        kanaVocab: formValues.kanaVocab,
        partOfSpeech: formValues.partOfSpeech,
        sentences: this.getUpdatedSentences(),
      };

      // Check if any changes were actually made.
      for (const [key, value] of Object.entries(updatedWord)) {
        if (this.wordToEdit[key] !== value) {
          this.wordUpdated.emit(updatedWord);
          break;
        }
      }
    }
  }

  public clearForm(): void {
    this.initializeForm();
  }

  public closeForm(): void {
    this.formClosed.emit();
  }

}
